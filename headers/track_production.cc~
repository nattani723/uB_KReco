

void CCKaonAnalyzer::trackRebuid(std::vector<art::Ptr<recob::Hit>>& hit_list,
				 art::FindManyP<recob::SpacePoint>& spacepoint_per_hit,
				 recob::Track& track)
{

  std::vector<art::Ptr<recob::SpacePoint>> spacepoint_vec; 
  pandora::CartesianPointVector pandora_hit_positions;

  for(size_t i_h=0; i_h<shower_spine_hit_list.size(); i_h++){

    spacepoint_vec.clear();
    spacepoint_vec = spacepoint_per_hit.at(shower_spine_hit_list[i_h].key()); 
    if(spacepoint_vec.size()!=1) continue;

    const TVector3 hit_position = spacepoint_vec[0]->XYZ();
    const pandora::CartesianVector pandora_hit_position(hit_position.X(), hit_position.Y(), hit_position.Z());
    pandora_hit_positions.push_back(pandora_hit_position);

  }

  //std::unique_ptr<std::vector<recob::Track>> outputTracks(new std::vector<recob::Track>);
  std::unique_ptr<recob::Track> outputTrack(new recob::Track);

  LArPandoraDetectorType* detType(detector_functions::GetDetectorType());
  const float wirePitchW(detType->WirePitchW());

  int track_counter = 0;
  const art::PtrMaker<recob::Track> makeTrackPtr(evt);

  //organise inputs

  PFParticleVector pfParticleVector, extraPfParticleVector;
  PFParticlesToSpacePoints pfParticlesToSpacePoints;
  PFParticlesToClusters pfParticlesToClusters;

  //collect pfparticle

  //Consider the end of K track candidate as pi+ 
  recob::vertex = track.End();

  double vertexXYZ[3] = {0., 0., 0.};
  vertex->XYZ(vertexXYZ);
  const pandora::CartesianVector vertexPosition(vertexXYZ[0], vertexXYZ[1], vertexXYZ[2]);


  lar_content::LArTrackStateVector trackStateVector;
  pandora::IntVector indexVector;

  lar_content::LArPfoHelper::GetSlidingFitTrajectory(pandora_hit_positions,
						     vertexPosition,
						     m_slidingFitHalfWindow,
						     wirePitchW,
						     trackStateVector,
						     &indexVector)

    //outputTracks->emplace_back(;
    outputTrack->LArPandoraTrackCreation::BuildTrack(0, trackStateVector));

}
