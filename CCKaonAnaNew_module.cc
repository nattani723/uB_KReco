////////////////////////////////////////////////////////////////////////
// Class:       CCKaonAnaNew
// Module Type: analyzer
// File:        CCKaonAnaNew_module.cc
//
// Generated at Sun Mar  7 00:18:35 2021 by Jairo Hernan Rodriguez Rondon using artmod
// from cetpkgsupport v1_14_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/View.h"
#include "canvas/Persistency/Common/Ptr.h"
#include "canvas/Persistency/Common/PtrVector.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"
#include "canvas/Persistency/Common/FindMany.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Utilities/make_tool.h"


#include "larcore/Geometry/Geometry.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "lardataobj/MCBase/MCShower.h"
#include "lardataobj/MCBase/MCTrack.h"
#include "lardataobj/MCBase/MCStep.h"
#include "nusimdata/SimulationBase/MCFlux.h"
#include "lardataobj/Simulation/SimChannel.h"
#include "lardataobj/Simulation/AuxDetSimChannel.h"
#include "lardataobj/AnalysisBase/Calorimetry.h"
#include "lardataobj/AnalysisBase/ParticleID.h"
#include "lardataobj/RawData/RawDigit.h"
#include "lardataobj/RawData/raw.h"
#include "lardataobj/RawData/BeamInfo.h"
#include "lardataobj/RawData/TriggerData.h"
#include "lardata/Utilities/AssociationUtil.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "larcoreobj/SummaryData/POTSummary.h"

#include "lardataobj/AnalysisBase/BackTrackerMatchingData.h"
#include "nusimdata/SimulationBase/MCParticle.h"

#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/Shower.h"
#include "lardataobj/RecoBase/Cluster.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/EndPoint2D.h"
#include "lardataobj/RecoBase/Vertex.h"
#include "lardataobj/RecoBase/OpFlash.h"
#include "lardataobj/RecoBase/PFParticle.h"
#include "lardataobj/RecoBase/Wire.h"
#include "lardataobj/RecoBase/MCSFitResult.h"
#include "larcoreobj/SimpleTypesAndConstants/geo_types.h"
#include "larreco/Deprecated/BezierTrack.h"
#include "larreco/RecoAlg/TrackMomentumCalculator.h"
#include "larsim/EventWeight/Base/MCEventWeight.h"
#include "ubobj/Trigger/ubdaqSoftwareTriggerData.h"
#include "lardataobj/AnalysisBase/CosmicTag.h"
#include "lardataobj/AnalysisBase/FlashMatch.h"
#include "lardataobj/AnalysisBase/T0.h"
#include "ubobj/Optical/UbooneOpticalFilter.h"
#include "ubana/AnalysisTree/MCTruth/IMCTruthMatching.h"

#include "lardataobj/RecoBase/PFParticleMetadata.h"
    

#include "larpandora/LArPandoraInterface/LArPandoraHelper.h"
#include "larevt/SpaceChargeServices/SpaceChargeService.h"
#include "lardata/DetectorInfoServices/DetectorClocksService.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"

#include "ubana/ParticleID/Algorithms/uB_PlaneIDBitsetHelperFunctions.h"

#include "canvas/Persistency/Common/TriggerResults.h" 
#include "fhiclcpp/ParameterSetRegistry.h" 

#include <cstddef> // std::ptrdiff_t
#include <cstring> // std::memcpy()
#include <vector>
#include <map>
#include <iterator> // std::begin(), std::end()
#include <string>
#include <sstream>
#include <fstream>
#include <algorithm>
#include <functional> // std::mem_fun_ref
#include <typeinfo>
#include <memory> // std::unique_ptr<>

#include "TTree.h"
#include "TTimeStamp.h"

using std::string;
using std::cout;
using std::endl;
using std::vector;
using std::map;

class CCKaonAnaNew;

class CCKaonAnaNew : public art::EDAnalyzer {
public:
  explicit CCKaonAnaNew(fhicl::ParameterSet const & p);
  //virtual ~CCKaonAnatest();
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  CCKaonAnaNew(CCKaonAnaNew const &) = delete;
  CCKaonAnaNew(CCKaonAnaNew &&) = delete;
  CCKaonAnaNew & operator = (CCKaonAnaNew const &) = delete;
  CCKaonAnaNew & operator = (CCKaonAnaNew &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;
  void reset();

  // Selected optional functions.
  void beginJob() override;
  void beginRun(art::Run const & r) override;
  void beginSubRun(art::SubRun const & sr) override;
  void endJob() override;
  void endRun(art::Run const & r) override;
  void endSubRun(art::SubRun const & sr) override;
  bool isInsideVolume(string volume, double x, double y, double z);
  bool isInsideVolume(string volume, const TVector3& v) {
      return isInsideVolume(volume, v.X(), v.Y(), v.Z());
    }

//  void reconfigure(fhicl::ParameterSet const & p) override;
//  void respondToCloseInputFile(art::FileBlock const & fb) override;
//  void respondToCloseOutputFiles(art::FileBlock const & fb) override;
//  void respondToOpenInputFile(art::FileBlock const & fb) override;
//  void respondToOpenOutputFiles(art::FileBlock const & fb) override;

private:

  // Declare member data here.
  //
  TTree *fTree;

  int run;
  int subrun;
  int event;

  string fPFParticleLabel;          ///< The label for the shower producer from PFParticles
  string fTrackLabel;
  string fCaloLabel;
  string fLArG4Label;
  string fHitTruthAssnLabel;
  string fHitTrackAssnLabel;
  string fHitLabel;
  Int_t npfp;
  Int_t nprimary;
  Int_t nprimarydg;
  //vector <float> *dgtrklen;
  vector< vector< float > > dgtrkdEdx;
  vector< vector< float > > dgresrange;
  map< int, vector< float > > maptr;
  vector< bool > *longdgtrk;

};


CCKaonAnaNew::CCKaonAnaNew(fhicl::ParameterSet const & p)
  :  EDAnalyzer(p)
    ,longdgtrk(nullptr)
{

   fPFParticleLabel = p.get<string>("PFParticleLabel");
   fTrackLabel = p.get<string>("TrackLabel");
   fCaloLabel = p.get<string>("CalorimetryLabel");
   fLArG4Label = p.get<string>("LArG4Label");
  fTrackLabel = p.get< std::string >("TrackLabel", "pandoraNu::OverlayRecoStage2");
  fHitLabel   = p.get< std::string >("HitLabel", "pandoraCosmicHitRemoval::OverlayRecoStage2");
  fHitTrackAssnLabel = p.get< std::string >("HitTrackAssnLabel", "pandoraNu::OverlayRecoStage2");
  fHitTruthAssnLabel = p.get< std::string >("HitTruthAssnLabel", "pandoraCosmicHitRemoval::OverlayRecoStage2");


  //fTrackLabel = p.get< std::string >("TrackLabel", "pandoraNu::OverlayRecoStage2");
  //fHitLabel   = p.get< std::string >("HitLabel", "pandoraCosmicHitRemoval::OverlayRecoStage2");
  //fHitTrackAssnLabel = p.get< std::string >("HitTrackAssnLabel", "pandoraNu::OverlayRecoStage2");
  //fHitTruthAssnLabel = p.get< std::string >("HitTruthAssnLabel", "pandoraCosmicHitRemoval::OverlayRecoStage2");

  //m_pfp_producer = p.get< std::string >("pfp_producer","pandora");

  //m_showerLabel = p.get<std::string>("ShowerLabel");

  
}


void CCKaonAnaNew::beginJob()
{
  // Implementation of optional member function here.
   
   art::ServiceHandle< art::TFileService > tfs;
   fTree = tfs->make<TTree>("tree", "Analysis");
   fTree->Branch("dEdx", "vector<vector<float>>", &dgtrkdEdx);
   fTree->Branch("resrange", "vector<vector<float>>", &dgresrange);
   fTree->Branch("istheLongest", &longdgtrk);
   fTree->Branch("maptr", &maptr);
}


void CCKaonAnaNew::analyze(art::Event const & e)
{
  // Implementation of required member function here.
  //
  reset();
   
   event = e.id().event();
   run = e.run();
   subrun = e.subRun();

   art::Handle< vector<simb::MCTruth> > mcnu;
   e.getByLabel("generator", mcnu);
   simb::MCTruth nuinfo = mcnu->at(0);
   

 //for(const simb::MCTruth  &mc : mcnu){
 
 
                 //cout << "particles mctruth: " << mcnu->at(0).GetParticle().PdgCode() <<endl;
                 //cout << "particles mctruth: " << mcnu->size() <<endl;
 //} 


   //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   // Events accepted by CCInclusive filter
  
   bool ccincfil = 0;
   art::InputTag trigResInputTag("TriggerResults","","OverlayFiltersPostStage2"); // the last is the name of process where the filters were run
   art::Handle<art::TriggerResults> trigRes;
   e.getByLabel(trigResInputTag,trigRes);
   if (trigRes.isValid()){
   fhicl::ParameterSet pset;
      if (!fhicl::ParameterSetRegistry::get(trigRes->parameterSetID(), pset)) { throw cet::exception("PSet Not Found???"); }
      std::vector<std::string> trigger_path_names = pset.get<std::vector<std::string> >("trigger_paths", {});
      if (trigger_path_names.size()!=trigRes->size()) { throw cet::exception("Size mismatch???"); }
      for (size_t itp=0;itp<trigRes->size();itp++) {

              //cout << "\nAll triggerpath names: "  << trigger_path_names.at(itp) << "\n" << endl;

         if (trigger_path_names.at(itp)=="NuCC" ) { 
            ccincfil = trigRes->at(itp).accept(); 
         }
      
      }
    }

   if (ccincfil) { 

      cout << "Accepted  by NuCCInclusiveFilter" <<endl; 

   } else { cout << "Rejected by NuCCInclusiveFilter" <<endl; return;}


   //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

   cout << "\n\nRun:\t\t" << run << "\t\tSubrun:\t\t" << subrun << "\t\tEvent:\t\t" << event <<endl;

   cout << "Current Mode: " << nuinfo.GetNeutrino().CCNC() << endl;
   cout << "Neutrino Mode: " << nuinfo.GetNeutrino().Mode() << endl;
   cout << "Interaction Mode: " << nuinfo.GetNeutrino().InteractionType() << endl;

   art::Handle< vector< recob::PFParticle > > pfphandle;
   vector< art::Ptr< recob::PFParticle > > pfpvector;
   vector< art::Ptr< recob::PFParticle > > pfpvectorPandora;

   if(e.getByLabel(fPFParticleLabel,pfphandle)) art::fill_ptr_vector(pfpvector,pfphandle);
   if(!pfpvector.size()) return;

   vector< art::Ptr< recob::Track > > trkvec;
   art::Handle< vector <recob::Track> > trkhandle;
   if(e.getByLabel(fTrackLabel, trkhandle)) art::fill_ptr_vector(trkvec, trkhandle);

    art::Handle< std::vector< recob::Hit > > hitHandle;
    e.getByLabel(fHitLabel, hitHandle);

    art::FindManyP< larpandoraobj::PFParticleMetadata > pfpmeta(pfphandle,e,"pandora");



    art::Handle< std::vector< recob::Hit > > hitHandleL;
    e.getByLabel("gaushit", hitHandleL);

    art::FindManyP< recob::Hit > hitsFromTrack(trkhandle, e, fHitTrackAssnLabel); 
    art::FindMany< simb::MCParticle, anab::BackTrackerHitMatchingData > particlesPerHit(hitHandle, e, fHitTruthAssnLabel);

    //art::FindManyP<recob::Cluster> theHitAssns(hitHandleL, e, "pandora");
    art::FindManyP<recob::Cluster> theClusterAssns(pfphandle, e, "pandora");

   npfp = pfpvector.size();

   size_t nuID = 99999;

   vector <float> dgkey;
   //float longdglen = -99999;
   int lonID = -1;
   
   for(const art::Ptr< recob::PFParticle > &pfp : pfpvector){
      
      //cout << "Pdg: " << pfp->PdgCode() << "\t" << pfp->Parent() << "\t" << pfp->Self() <<endl;
      if((pfp->IsPrimary() && (pfp->PdgCode() == 14))){

        nuID = pfp->Self();
        nprimarydg = pfp->NumDaughters();
        ++nprimary;
        cout << "NeutrinoID:\t\t" << nuID << endl;
        cout << "# of Daughters:\t\t" << nprimarydg <<endl;

      }

   }

   cout << "# of primaries:\t\t" << nprimary <<endl;




   if(nprimary == 0) return;

   art::FindManyP< recob::Track > trkasso(pfpvector, e, fTrackLabel);
   art::FindManyP<anab::T0> pfpmuonasso(pfpvector, e, "NuCCproducer");


   art::FindManyP<recob::Slice> nuslice(pfpvector, e, "pandora");

   
   size_t pfpkey = 999999;

   for(const art::Ptr< recob::PFParticle > &pfp : pfpvector){

      const std::vector< art::Ptr<larpandoraobj::PFParticleMetadata> > &pfParticleMetadataList(pfpmeta.at(pfp.key()));

   if (pfParticleMetadataList.empty()) continue;

   
   for (const art::Ptr<larpandoraobj::PFParticleMetadata> &pfpmd : pfParticleMetadataList ) {
      auto pfParticlePropertiesMap = pfpmd->GetPropertiesMap();
      if (pfParticlePropertiesMap.empty()) continue; //cout << pfParticlePropertiesMap.size() << endl;
        for (std::map<std::string, float>::const_iterator it = pfParticlePropertiesMap.begin(); it != pfParticlePropertiesMap.end(); ++it) {
         if(!(it->first == "TrackScore")) continue;
         cout << "PFParticle properties: " << it->first << " Key: " << pfpmd.key() << " Value: " << it->second << endl;
         pfpkey = pfp.key();
         pfpvectorPandora.push_back(pfp);
      }
   }// for all metadata items in the particle metadata
   if(pfp.key() == pfpkey){
     cout << "PFP ID: " <<  pfp->Self() <<endl;
     cout << "PFP IsPrimary: " << pfp->IsPrimary() <<endl;
     cout << "PFP parent: " << pfp->Parent() <<endl;
     cout << "PFP PDG: " << pfp->PdgCode() <<endl;
     cout << "PFP key: " << pfp.key() << "=====================\n" <<endl;
   }

   //}// for entries in list


   auto slices = nuslice.at(pfp.key());

   cout << "Slices: " << slices.size() << endl;
     //" ID: " << slices.ID() << endl;
   }

   for(const art::Ptr< recob::Track > &trk : trkvec ){        

      if(trkasso.at(trk.key()).size()!=1) continue;

      cout << "All tracks in pfp primaries:" << endl;
      cout << "Length: " << trk->Length() << "\t\tKey: " << trk.key() << "\t\tT0Asso: " << pfpmuonasso.at(trk.key()).size() <<endl;

            //dgkey.push_back(trk.key());
            
   }


   for(const art::Ptr< recob::PFParticle > &pfp : pfpvector){

      if(pfp->Parent() != nuID) continue;

      cout << "Control 1" << " NuID: "  << nuID << " pfp parent: " << pfp->Parent() << " pfp ID: " << pfp.key() <<endl;

      vector < art::Ptr< recob::Track > > pfptracks = trkasso.at(pfp.key());

      vector < art::Ptr<recob::Cluster> > clusters = theClusterAssns.at(pfp.key());

      //for(const art::Ptr < recob::Cluster > &cls : clusters ){

         

      //}

      if(!pfptracks.empty()){

      //   for(const art::Ptr< recob::Track > &trk : trkvec ){
                 
      //if(trkasso.at(trk.key()).size()!=1) continue;

         for(const art::Ptr< recob::Track > &trk : pfptracks ){
         
            //const recob::Track& ftrk = *trk;
            //dgtrklen->push_back(ftrk.Length());
            //cout << "All tracks WITH association to pfp primaries:" << endl;
            cout << "Length: " << trk->Length() << "\t\tKey: " << trk.key() << "\t\tT0Asso: " << pfpmuonasso.at(trk.key()).size() << " PFParticle Key: " << pfp.key() <<endl;
            dgkey.push_back(trk.key());
            //cout << " - - - - Track Key: " << trk.key() <<endl;

            
         }

      }
   
   }



      for(auto &trk : dgkey ){
        std::vector< art::Ptr< recob::Hit > > hits = hitsFromTrack.at(trkvec.at(trk).key());


        cout << "Track Key: " << trkvec.at(trk).key() << "   Track Key vec: " << trk <<endl;
        cout << "Hits in track: " << hits.size() <<endl;
        cout << "Track length: " << trkvec.at(trk)->Length() << endl;
        std::unordered_map< int, double> trkide;
        double maxe = -1;
        double tote = 0;

        //int tID = -99999;
        
        float matchedParticle = -9999;
       
        std::vector< simb::MCParticle const* > particleVec;
        std::vector< anab::BackTrackerHitMatchingData const* > matchVec;
        std::unordered_map<int, int> freq;
        std::unordered_map<int, std::unordered_map<int,int>> counterp;

        //std::cout << "before hit loop" << std::endl;        

        for (size_t i_hit = 0; i_hit < hits.size(); ++i_hit){

        //std::vector<art::Ptr<simb::MCParticle>> const& mcpart = particlesPerHit.at(i_hit);
        //std::cout << "Track: " << i_track << "   nPart: " << mcpart.size() << std::endl;

            particleVec.clear();
            matchVec.clear();
            particlesPerHit.get(hits[i_hit].key(), particleVec, matchVec);
            //if(particleVec.size()!=0) cout << "Hit number: " << i_hit <<endl;


            for (size_t i_particle = 0; i_particle < particleVec.size(); ++i_particle){

                trkide[ particleVec[i_particle]->TrackId() ] += matchVec[i_particle]->energy;

                tote += matchVec[i_particle]->energy;


                //trkide[ particleVec[i_particle]->TrackId() ]++;
                //tote++;
                    //std::cout << "Track: " << i_track << std::endl;        
                    //std::cout << "============ Hit: " << i_hit << std::endl;        
                    //std::cout << "E: " << trkide[ particleVec[i_particle]->TrackId() ]  << "\t=== PDG: " << particleVec[i_particle]->PdgCode() <<std::endl;

                    counterp[particleVec[i_particle]->PdgCode()][particleVec[i_particle]->TrackId()]++;

                    freq[particleVec[i_particle]->PdgCode()]++;

                if ( trkide[ particleVec[i_particle]->TrackId() ] > maxe ){
                    
                     
                    //std::cout << "Track: " << i_track << std::endl;        
                    //std::cout << "Hit: " << i_hit << std::endl;        
                    //std::cout << "Hit: " << i_hit << "   " << hits[i_hit].key() << "   " << particleVec.size() << "   " << matchVec.size() << std::endl;        
                    //std::cout << " &&&&&&&&&& Particle: " << i_particle << std::endl;
                    //tID = particleVec[i_particle]->TrackId(); 
                    maxe = trkide[ particleVec[i_particle]->TrackId() ];
                    matchedParticle = particleVec[i_particle]->PdgCode();
                    //std::cout << " &&&&&&&&&& max E: " << maxe <<std::endl;
                    //std::cout << "@@@@@ PDG max Edep @@@@@: " << particleVec[i_particle]->PdgCode() <<std::endl;
                }

            }

//        if(particleVec.size()!=0) std::cout << "**********************************" <<std::endl;

        }

//        if(trackPtrVector.size()!=0) std::cout << "&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&" <<std::endl;
        float purity = maxe/tote;
        //std::cout << "[UsingRecoToTrueMatcher] Particle Matched to track with id " << thisTrack->ID() << " is MCParticle with PDG code " << matchedParticle->PdgCode() << std::endl; 
        //std::cout << " is MCParticle with PDG code " << matchedParticle << std::endl; 
        //std::cout << "[UsingRecoToTrueMatcher] Match purity-completeness: " << purity << std::endl;
        //
   //        const simb::MCParticle *particle = pi_serv->TrackIdToParticle_P(tID);
   //if (particle && trackPtrVector.size()!=0 && matchedParticle!=-9999){
   //   cout<<"PDG New: "<<particle->PdgCode()<<endl;
   //}
  //
//cout << "Tracks ID: " << tID << endl;
if(trkvec.size()!=0 && matchedParticle!=-9999){
        //std::cout << "################################################" <<std::endl;
        std::cout << "@@@@@ PDG max Edep @@@@@: " << matchedParticle <<std::endl;
        std::cout << "Match purity-completeness: " << purity << std::endl;
        double maxp = -1;
        for(auto& i:counterp){
        
        for(auto& m:i.second){
                if((m.second/(double)hits.size()) > maxp){
                maxp =(m.second/(double)hits.size());  
                std::cout << "PDG: " << i.first  << " particle ID: " << m.first << "\tHits: " << m.second << " Purity:" << m.second/(double)hits.size() <<std::endl;
                }
        
        }
        }
        std::cout << "################################################" <<std::endl;
}
    }// loop tracks




/*
      art::FindManyP< anab::Calorimetry > caloasso(trkvec, e, fCaloLabel);
      int ck=0;

      for(auto &trk : dgkey ){
         
         //cout << "Key:\t\t" << trk << endl;
         vector< art::Ptr< anab::Calorimetry > > trkcalo = caloasso.at(trk);
         if(trkcalo.empty()) continue;

         if(trkvec.at(trk)->Length() > longdglen){
            
               longdglen = trkvec.at(trk)->Length();
               lonID  = trkvec.at(trk)->ID(); 
            
            }


         for(const art::Ptr< anab::Calorimetry > &cal : trkcalo){
            
            if(!cal->PlaneID().isValid) continue;

            int planenum = cal->PlaneID().Plane;

            if(planenum != 2) continue;

            //cout << "Plane ID: " << planenum <<endl;

            //for(auto& c : cal->dEdx()){
            //cout << "dEdx: " << c <<endl;
            //}

            dgtrkdEdx.push_back(cal->dEdx());
            dgresrange.push_back(cal->ResidualRange());

            maptr[ck] = cal->dEdx();
            
         }

ck++;
         
      } 
*/

         for(auto& dgk : dgkey ){
         
            if(trkvec.at(dgk)->ID() == lonID) longdgtrk->push_back(true);
            else longdgtrk->push_back(false); 

         }


   //vector< art::Ptr< simb::MCParticle > > kdecay;
   vector<float> kkey;

   art::Handle< std::vector< simb::MCParticle > > mcphandle;
   vector< art::Ptr< simb::MCParticle > > mcpvec;
   if(e.getByLabel(fLArG4Label, mcphandle)) art::fill_ptr_vector(mcpvec, mcphandle);
   //art::FindManyP< anab::Calorimetry > caloasso(trkvec, e, fCaloLabel);
   //
   
   //float kp=0;
   for(const art::Ptr< simb::MCParticle > &plist : mcpvec){
      if(plist->Process() == "primary"){

              
         cout << "PDG primary: " << plist->PdgCode() << "\tTrackID: " << plist->TrackId() << "\tMotherID: " << plist->Mother() << "\tProcess: "<< plist->Process() << "\tkey: " << plist.key() <<endl;

         kkey.push_back(plist.key());
         //kp = plist->TrackId();

      }

      //cout << "===========================" << endl;
   }
/*
   int kine = -1;
   for(auto& k : kkey){   

     for(const art::Ptr< simb::MCParticle > &plist : mcpvec){
      if(mcpvec.at(k)->PdgCode()!=13 && plist->Mother() == mcpvec.at(k)->TrackId()){
      //if( mcpvec.at(k)->PdgCode()==321 && plist->Mother() == mcpvec.at(k)->TrackId() && (plist->Process()=="Decay" || plist->Process()=="kaon+Inelastic")){

         cout << "PDG Daughter: " << plist->PdgCode() << "\tTrackID DG: " << plist->TrackId() << "\tMotherID DG: " << plist->Mother() << "\tProcess DG: "<< plist->Process() << "\tkey DG: " << plist.key() <<endl;
         if(plist->PdgCode()==321)kine = plist.key();
      }
   }

     for(const art::Ptr< simb::MCParticle > &plist : mcpvec){

      if(kine==-1) continue;
      if( plist->Mother() == mcpvec.at(kine)->TrackId()){

         cout << "PDG Dg ine: " << plist->PdgCode() << "\tTrackID DG ine: " << plist->TrackId() << "\tMotherID DG ine: " << plist->Mother() << "\tProcess DG ine: "<< plist->Process() << "\tkey DG ine: " << plist.key() <<endl;
      }

      }
      
   }

*/
   if(nuID == 99999) return;

   cout << "\n\n\n" << endl;

   fTree->Fill();
}

void CCKaonAnaNew::beginRun(art::Run const & r)
{
  // Implementation of optional member function here.
}

void CCKaonAnaNew::beginSubRun(art::SubRun const & sr)
{
  // Implementation of optional member function here.
}

void CCKaonAnaNew::endJob()
{
  // Implementation of optional member function here.
}

void CCKaonAnaNew::endRun(art::Run const & r)
{
  // Implementation of optional member function here.
}

void CCKaonAnaNew::endSubRun(art::SubRun const & sr)
{
  // Implementation of optional member function here.
}


 
bool CCKaonAnaNew::isInsideVolume(string volume, double x, double y, double z)
{
  if (volume=="TPC") {
    if (x>0 && x<256.35 && y>-116.5 && y<116.5 && z>0 && z<1036.8) {
      return true;
    }
  }
  else if (volume=="5cmTPC") {
    if (x>5 && x<251.35 && y>-111.5 && y<111.5 && z>5 && z<1031.8) {
      return true;
    }
  }
  else if (volume=="CCInclusiveTPC") {
    if (x>10 && x<246.35 && y>-106.5 && y<106.5 && z>10 && z<986.8) {
      return true;
    }
  }
  return false;
}

void CCKaonAnaNew::reset(){

   run = -1;
   subrun = -1;
   event = -1;
   npfp = 99999;
   nprimary = 0;
   nprimarydg = 99999;
   //dgtrklen->clear();
   dgtrkdEdx.clear();
   dgresrange.clear();
   longdgtrk->clear();
   maptr.clear();


}
/*
void CCKaonAnatest::reconfigure(fhicl::ParameterSet const & p)
{
  // Implementation of optional member function here.
}

void CCKaonAnatest::respondToCloseInputFile(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void CCKaonAnatest::respondToCloseOutputFiles(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void CCKaonAnatest::respondToOpenInputFile(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void CCKaonAnatest::respondToOpenOutputFiles(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}
*/
DEFINE_ART_MODULE(CCKaonAnaNew)
