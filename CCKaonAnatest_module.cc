////////////////////////////////////////////////////////////////////////
// Class:       CCKaonAnatest
// Module Type: analyzer
// File:        CCKaonAnatest_module.cc
//
// Generated at Sun Mar  7 00:18:35 2021 by Jairo Hernan Rodriguez Rondon using artmod
// from cetpkgsupport v1_14_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/View.h"
#include "canvas/Persistency/Common/Ptr.h"
#include "canvas/Persistency/Common/PtrVector.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"
#include "canvas/Persistency/Common/FindMany.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Utilities/make_tool.h"


#include "larcore/Geometry/Geometry.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "lardataobj/MCBase/MCShower.h"
#include "lardataobj/MCBase/MCTrack.h"
#include "lardataobj/MCBase/MCStep.h"
#include "nusimdata/SimulationBase/MCFlux.h"
#include "lardataobj/Simulation/SimChannel.h"
#include "lardataobj/Simulation/AuxDetSimChannel.h"
#include "lardataobj/AnalysisBase/Calorimetry.h"
#include "lardataobj/AnalysisBase/ParticleID.h"
#include "lardataobj/RawData/RawDigit.h"
#include "lardataobj/RawData/raw.h"
#include "lardataobj/RawData/BeamInfo.h"
#include "lardataobj/RawData/TriggerData.h"
#include "lardata/Utilities/AssociationUtil.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "larcoreobj/SummaryData/POTSummary.h"

#include "lardataobj/AnalysisBase/BackTrackerMatchingData.h"
#include "nusimdata/SimulationBase/MCParticle.h"

#include "larsim/MCCheater/BackTracker.h"
#include "larsim/MCCheater/ParticleInventory.h"
#include "larsim/MCCheater/BackTrackerService.h"
#include "larsim/MCCheater/ParticleInventoryService.h"

#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/Shower.h"
#include "lardataobj/RecoBase/Cluster.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/EndPoint2D.h"
#include "lardataobj/RecoBase/Vertex.h"
#include "lardataobj/RecoBase/OpFlash.h"
#include "lardataobj/RecoBase/PFParticle.h"
#include "lardataobj/RecoBase/Wire.h"
#include "lardataobj/RecoBase/MCSFitResult.h"
#include "larcoreobj/SimpleTypesAndConstants/geo_types.h"
#include "larreco/Deprecated/BezierTrack.h"
#include "larreco/RecoAlg/TrackMomentumCalculator.h"
#include "larsim/EventWeight/Base/MCEventWeight.h"
#include "ubobj/Trigger/ubdaqSoftwareTriggerData.h"
#include "lardataobj/AnalysisBase/CosmicTag.h"
#include "lardataobj/AnalysisBase/FlashMatch.h"
#include "lardataobj/AnalysisBase/T0.h"
#include "ubobj/Optical/UbooneOpticalFilter.h"
#include "ubana/AnalysisTree/MCTruth/IMCTruthMatching.h"

#include "larpandora/LArPandoraInterface/LArPandoraHelper.h"
#include "larevt/SpaceChargeServices/SpaceChargeService.h"
#include "lardata/DetectorInfoServices/DetectorClocksService.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"

#include "ubana/ParticleID/Algorithms/uB_PlaneIDBitsetHelperFunctions.h"

#include <cstddef> // std::ptrdiff_t
#include <cstring> // std::memcpy()
#include <vector>
#include <map>
#include <iterator> // std::begin(), std::end()
#include <string>
#include <sstream>
#include <fstream>
#include <algorithm>
#include <functional> // std::mem_fun_ref
#include <typeinfo>
#include <memory> // std::unique_ptr<>

#include "TTree.h"
#include "TTimeStamp.h"

using std::string;
using std::cout;
using std::endl;

//namespace cheat {
class CCKaonAnatest;
//}

class CCKaonAnatest : public art::EDAnalyzer {
public:
  explicit CCKaonAnatest(fhicl::ParameterSet const & p);
  //virtual ~CCKaonAnatest();
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  CCKaonAnatest(CCKaonAnatest const &) = delete;
  CCKaonAnatest(CCKaonAnatest &&) = delete;
  CCKaonAnatest & operator = (CCKaonAnatest const &) = delete;
  CCKaonAnatest & operator = (CCKaonAnatest &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

  // Selected optional functions.
  void beginJob() override;
  void beginRun(art::Run const & r) override;
  void beginSubRun(art::SubRun const & sr) override;
  void endJob() override;
  void endRun(art::Run const & r) override;
  void endSubRun(art::SubRun const & sr) override;
  bool isInsideVolume(string volume, double x, double y, double z);
  bool isInsideVolume(string volume, const TVector3& v) {
      return isInsideVolume(volume, v.X(), v.Y(), v.Z());
    }

//  void reconfigure(fhicl::ParameterSet const & p) override;
//  void respondToCloseInputFile(art::FileBlock const & fb) override;
//  void respondToCloseOutputFiles(art::FileBlock const & fb) override;
//  void respondToOpenInputFile(art::FileBlock const & fb) override;
//  void respondToOpenOutputFiles(art::FileBlock const & fb) override;

private:

  // Declare member data here.

  int run;
  int subRun;
  int event;
  std::string fTrackLabel;
  std::string fHitLabel;
  std::string fHitTrackAssnLabel;
  std::string fHitTruthAssnLabel;
  std::string m_pfp_producer;
  std::string m_trackLabel;           ///< The label for the track producer from PFParticles
  std::string m_showerLabel;          ///< The label for the shower producer from PFParticles

};


CCKaonAnatest::CCKaonAnatest(fhicl::ParameterSet const & p)
  :  EDAnalyzer(p)  // ,
 // More initializers here.
{

  fTrackLabel = p.get< std::string >("TrackLabel", "pandoraNu::OverlayRecoStage2");
  fHitLabel   = p.get< std::string >("HitLabel", "pandoraCosmicHitRemoval::OverlayRecoStage2");
  fHitTrackAssnLabel = p.get< std::string >("HitTrackAssnLabel", "pandoraNu::OverlayRecoStage2");
  fHitTruthAssnLabel = p.get< std::string >("HitTruthAssnLabel", "pandoraCosmicHitRemoval::OverlayRecoStage2");

  m_pfp_producer = p.get< std::string >("pfp_producer","pandora");

  m_trackLabel = p.get<std::string>("TrackLabel");
  //m_showerLabel = p.get<std::string>("ShowerLabel");

}

void CCKaonAnatest::analyze(art::Event const & e)
{
  // Implementation of required member function here.
// /*
  run = e.run();
  subRun = e.subRun();
  event = e.event();
  
  std::cout << "[UsingRecoToTrueMatcher] Processing event (run.subrun.event)   " <<
        run << "." <<
        subRun << "." <<
        event << std::endl;

    art::Handle< std::vector< recob::Track > > trackHandle;
    e.getByLabel(fTrackLabel, trackHandle);
    std::vector< art::Ptr< recob::Track > > trackPtrVector;
    art::fill_ptr_vector(trackPtrVector, trackHandle);

    art::Handle< std::vector< recob::Hit > > hitHandle;
    e.getByLabel(fHitLabel, hitHandle);
    art::FindManyP< recob::Hit > hitsFromTrack(trackHandle, e, fHitTrackAssnLabel); 
    art::FindMany< simb::MCParticle, anab::BackTrackerHitMatchingData > particlesPerHit(hitHandle, e, fHitTruthAssnLabel);

  art::Handle<std::vector<recob::PFParticle>> pfparticles;
  e.getByLabel(m_pfp_producer, pfparticles);


  for (unsigned int i=0; i<pfparticles->size(); ++i) {

    art::Ptr<recob::PFParticle> pfparticle(pfparticles,i);

    if(pfparticle->Parent() && pfparticle->PdgCode()==14){

      cout << "PDG parent: " << pfparticle->PdgCode() <<endl;
      cout << "PDG id: " << pfparticle->Self() <<endl;
      cout << "PDG parent id: " << pfparticle->Parent() <<endl;

    }

  }
    
    //std::cout << "before track loop" << std::endl;

    for (size_t i_track = 0; i_track < trackPtrVector.size(); i_track++){
        art::Ptr< recob::Track > thisTrack = trackPtrVector.at(i_track);
        std::vector< art::Ptr< recob::Hit > > hits = hitsFromTrack.at(thisTrack.key());


        cout << "Track ID: " << thisTrack.key() <<endl;
        cout << "Hits in track: " << hits.size() <<endl;
        cout << "Track length: " << thisTrack->Length() << endl;
        std::unordered_map< int, double> trkide;
        double maxe = -1;
        double tote = 0;

        //int tID = -99999;
        
        float matchedParticle = -9999;
       
        std::vector< simb::MCParticle const* > particleVec;
        std::vector< anab::BackTrackerHitMatchingData const* > matchVec;
        std::unordered_map<int, int> freq;
        std::unordered_map<int, std::unordered_map<int,int>> counterp;

        //std::cout << "before hit loop" << std::endl;        

        for (size_t i_hit = 0; i_hit < hits.size(); ++i_hit){

        //std::vector<art::Ptr<simb::MCParticle>> const& mcpart = particlesPerHit.at(i_hit);
        //std::cout << "Track: " << i_track << "   nPart: " << mcpart.size() << std::endl;

            particleVec.clear();
            matchVec.clear();
            particlesPerHit.get(hits[i_hit].key(), particleVec, matchVec);
            //if(particleVec.size()!=0) cout << "Hit number: " << i_hit <<endl;


            for (size_t i_particle = 0; i_particle < particleVec.size(); ++i_particle){

                trkide[ particleVec[i_particle]->TrackId() ] += matchVec[i_particle]->energy;

                tote += matchVec[i_particle]->energy;


                //trkide[ particleVec[i_particle]->TrackId() ]++;
                //tote++;
                    //std::cout << "Track: " << i_track << std::endl;        
                    std::cout << "============ Hit: " << i_hit << std::endl;        
                    std::cout << "E: " << trkide[ particleVec[i_particle]->TrackId() ]  << "\t=== PDG: " << particleVec[i_particle]->PdgCode() <<std::endl;

                    counterp[particleVec[i_particle]->PdgCode()][particleVec[i_particle]->TrackId()]++;

                    freq[particleVec[i_particle]->PdgCode()]++;

                if ( trkide[ particleVec[i_particle]->TrackId() ] > maxe ){
                    
                     
                    //std::cout << "Track: " << i_track << std::endl;        
                    //std::cout << "Hit: " << i_hit << std::endl;        
                    //std::cout << "Hit: " << i_hit << "   " << hits[i_hit].key() << "   " << particleVec.size() << "   " << matchVec.size() << std::endl;        
                    //std::cout << " &&&&&&&&&& Particle: " << i_particle << std::endl;
                    //tID = particleVec[i_particle]->TrackId(); 
                    maxe = trkide[ particleVec[i_particle]->TrackId() ];
                    matchedParticle = particleVec[i_particle]->PdgCode();
                    //std::cout << " &&&&&&&&&& max E: " << maxe <<std::endl;
                    //std::cout << "@@@@@ PDG max Edep @@@@@: " << particleVec[i_particle]->PdgCode() <<std::endl;
                }

            }

//        if(particleVec.size()!=0) std::cout << "**********************************" <<std::endl;

        }

//        if(trackPtrVector.size()!=0) std::cout << "&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&" <<std::endl;
        float purity = maxe/tote;
        //std::cout << "[UsingRecoToTrueMatcher] Particle Matched to track with id " << thisTrack->ID() << " is MCParticle with PDG code " << matchedParticle->PdgCode() << std::endl; 
        //std::cout << " is MCParticle with PDG code " << matchedParticle << std::endl; 
        //std::cout << "[UsingRecoToTrueMatcher] Match purity-completeness: " << purity << std::endl;
        //
   //        const simb::MCParticle *particle = pi_serv->TrackIdToParticle_P(tID);
   //if (particle && trackPtrVector.size()!=0 && matchedParticle!=-9999){
   //   cout<<"PDG New: "<<particle->PdgCode()<<endl;
   //}
  //
//cout << "Tracks ID: " << tID << endl;
if(trackPtrVector.size()!=0 && matchedParticle!=-9999){
        //std::cout << "################################################" <<std::endl;
        std::cout << "@@@@@ PDG max Edep @@@@@: " << matchedParticle <<std::endl;
        std::cout << "Match purity-completeness: " << purity << std::endl;
        for(auto& i:counterp){
        
        for(auto& m:i.second){
                std::cout << "PDG: " << i.first  << " particle ID: " << m.first << "\tHits: " << m.second << " Purity:" << m.second/(double)hits.size() <<std::endl;

        
        }
        }
        std::cout << "################################################" <<std::endl;
}
    }// loop tracks

   

}

void CCKaonAnatest::beginJob()
{
  // Implementation of optional member function here.
}

void CCKaonAnatest::beginRun(art::Run const & r)
{
  // Implementation of optional member function here.
}

void CCKaonAnatest::beginSubRun(art::SubRun const & sr)
{
  // Implementation of optional member function here.
}

void CCKaonAnatest::endJob()
{
  // Implementation of optional member function here.
}

void CCKaonAnatest::endRun(art::Run const & r)
{
  // Implementation of optional member function here.
}

void CCKaonAnatest::endSubRun(art::SubRun const & sr)
{
  // Implementation of optional member function here.
}


 
bool CCKaonAnatest::isInsideVolume(string volume, double x, double y, double z)
{
  if (volume=="TPC") {
    if (x>0 && x<256.35 && y>-116.5 && y<116.5 && z>0 && z<1036.8) {
      return true;
    }
  }
  else if (volume=="5cmTPC") {
    if (x>5 && x<251.35 && y>-111.5 && y<111.5 && z>5 && z<1031.8) {
      return true;
    }
  }
  else if (volume=="CCInclusiveTPC") {
    if (x>10 && x<246.35 && y>-106.5 && y<106.5 && z>10 && z<986.8) {
      return true;
    }
  }
  return false;
}


/*
void CCKaonAnatest::reconfigure(fhicl::ParameterSet const & p)
{
  // Implementation of optional member function here.
}

void CCKaonAnatest::respondToCloseInputFile(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void CCKaonAnatest::respondToCloseOutputFiles(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void CCKaonAnatest::respondToOpenInputFile(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void CCKaonAnatest::respondToOpenOutputFiles(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}
*/
DEFINE_ART_MODULE(CCKaonAnatest)
